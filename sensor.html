<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensor Setup Guide</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    aside img {
      width: 100%;
      max-width: 300px; /* Increase size for better visibility */
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Setup Guide</h1>
    <nav>
      <a href="index.html">Home</a>
      <a href="parts.html">Parts List</a>
      <a href="sensor.html">Sensor Setup</a>
      <a href="lidar.html">LiDAR Car</a>
    </nav>
    <button class="toggle-dark-btn" onclick="toggleDarkMode()">üåô Toggle Dark Mode</button>
  </header>

  <main>
    <section class="card">
      <details>
        <summary>üìã Overview & Setup</summary>
        <p>This guide walks you through building a robust, multi-sensor demo system using a Raspberry Pi 4B running Raspberry Pi OS. Each component is tested individually and then combined into one working system. This document is written to be accessible for beginners, complete with fallback advice and troubleshooting context.</p>
        <h3>Hardware Components</h3>
        <ul>
          <li>Ultrasonic Sensor (HC-SR04)</li>
          <li>LCD Display (1602 Parallel)</li>
          <li>ArduCam Camera Module (IMX708 with PiCamera2)</li>
        </ul>
        <h3>You‚Äôll learn:</h3>
        <ul>
          <li>GPIO wiring and hardware setup</li>
          <li>Library installation</li>
          <li>Full commented Python scripts</li>
          <li>How to use the terminal for testing</li>
          <li>How to troubleshoot common issues</li>
        </ul>
      </details>
    </section>
    <section class="card">
      <details>
        <summary>üçì Raspberry Pi Setup</summary>
    
        <h3>üì¶ What You Need</h3>
        <ul>
          <li>Raspberry Pi 4B (or 3B+)</li>
          <li>MicroSD Card (16GB or more, Class 10 recommended)</li>
          <li>MicroSD Card Reader</li>
          <li>Power Supply (5V 3A)</li>
          <li>HDMI Monitor, USB Keyboard and Mouse (for first-time setup)</li>
        </ul>
    
        <details>
          <summary>üñ•Ô∏è Step 1: Install Raspberry Pi OS</summary>
          <ol>
            <li>Download and install <a href="https://www.raspberrypi.com/software/" target="_blank">Raspberry Pi Imager</a> on your PC.</li>
            <li>Insert the SD card into your reader.</li>
            <li>Launch the Imager, select:
              <ul>
                <li><strong>OS:</strong> Raspberry Pi OS (64-bit)</li>
                <li><strong>Storage:</strong> Your SD card</li>
              </ul>
            </li>
            <li>Click "Next", enable SSH (if offered), and set username/password.</li>
            <li>Click "Write" and wait for it to finish.</li>
          </ol>
        
          <h4>‚ö†Ô∏è OS Customization Warning</h4>
          <p>After you click <strong>Next</strong> or <strong>Write</strong>, you may see a pop-up like this:</p>
        
          <div style="text-align: center;">
            <img src="media/os-customisation-warning.png" alt="OS Customisation Prompt" style="max-width: 600px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
          </div>
        
          <p>
            When this screen appears, click the <strong style="color: crimson;">NO</strong> button.
            <br />
            Do <em>not</em> apply OS customization unless you're preconfiguring advanced settings.
          </p>
        
          <div class="tip-box">
            <strong>üí° Tip:</strong> Clicking "NO" ensures a clean Raspberry Pi OS install for first-time setup.
          </div>
        
          <details>
            <summary>üñºÔ∏è Raspberry Pi Imager Screenshots</summary>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
              <div>
                <h4 style="text-align: center;">macOS</h4>
                <img src="media/imager-mac.png" alt="Raspberry Pi Imager on macOS" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
              <div>
                <h4 style="text-align: center;">Windows</h4>
                <img src="media/imager-win.png" alt="Raspberry Pi Imager on Windows" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
            </div>
          </details>
        </details>
        <details>
          <summary>‚öôÔ∏è Step 2: First Boot Setup</summary>
          <ol>
            <li>Insert SD card into the Pi and power it on.</li>
            <li>Follow the on-screen wizard to set up Wi-Fi and localization.</li>
            <li>Open Terminal and run system updates:</li>
          </ol>
          <div class="code-block">
            <pre><code>sudo apt update
        sudo apt upgrade -y
        sudo reboot</code></pre>
        </details>
        <details>
          <summary>üîß Step 3: Remote Access & Development Setup</summary>
          <details>
            <summary>üóïÔ∏è Step 1: Download and Install VS Code</summary>
            <ol>
              <li>Go to <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> and download the version for your OS.</li>
              <li>Install it using the standard installer.</li>
              <li>Launch VS Code and open the Extensions tab.</li>
              <li>Search for and install the <strong>"Remote - SSH"</strong> extension.</li>
            </ol>
          </details>
        
          <details>
            <summary>üåê Step 2: Set Up Remote Access Options</summary>
            <h4>üñ•Ô∏è Option A: Tailscale</h4>
            <p><strong>Tailscale</strong> is a secure VPN using WireGuard.</p>
            <h5>üíª On Your Computer:</h5>
            <ol>
              <li>Visit <a href="https://tailscale.com/download" target="_blank">tailscale.com/download</a>.</li>
              <li>Install and sign in.</li>
              <li>Click <strong>"Enable Tailscale"</strong>.</li>
            </ol>
            <h5>üçì On Your Raspberry Pi:</h5>
            <pre><code>curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up</code></pre>
        
            <h4>üåê Option B: Raspberry Pi Connect</h4>
            <ol>
              <li>Visit <a href="https://connect.raspberrypi.com/devices" target="_blank">connect.raspberrypi.com/devices</a>.</li>
              <li>Log in and register your Pi.</li>
              <li>Use the web interface to access terminal or desktop.</li>
            </ol>
          </details>
        
          <details>
            <summary>üîê Step 3: Connect via VS Code (SSH)</summary>
            <ol>
              <li>In VS Code, press <kbd>Ctrl/Cmd + Shift + P</kbd>.</li>
              <li>Select <strong>Remote-SSH: Connect to Host</strong>.</li>
              <li>Enter <code>pi@YOUR_TAILSCALE_IP</code>.</li>
              <li>Authenticate and start working directly on the Pi.</li>
            </ol>
        
            <h3>ü§∫ Which Should You Use?</h3>
            <div class="tip-box">
              <strong>üîß Use VS Code with Tailscale if you:</strong>
              <ul>
                <li>Want terminal + Git + code editing</li>
                <li>Prefer an IDE</li>
              </ul>
            </div>
            <div class="tip-box">
              <strong>üåê Use Raspberry Pi Connect if you:</strong>
              <ul>
                <li>Want fast access from a browser</li>
                <li>Don‚Äôt need full development tools</li>
              </ul>
            </div>
          </details>
        
        </details>
        
          </section>
          <section class="card">
            <details>
              <summary>üêç Python Setup + Virtual Environment (General Use)</summary>
          
              <h3>üí° Why Use a Virtual Environment?</h3>
              <p>
                On Raspberry Pi OS (especially Bookworm and newer), the system Python is protected. If you try to install packages directly using <code>pip3</code>, you may get this error:
              </p>
              <div class="code-block">
                <pre><code>error: externally-managed-environment</code></pre>
              </div>
              <p>
                A virtual environment is an isolated Python environment that lets you install and manage packages like <code>RPLCD</code>, <code>numpy</code>, or <code>flask</code> without interfering with the system Python or requiring <code>sudo</code>.
              </p>
          
              <details>
                <summary>‚öôÔ∏è Step 1: Install Required Tools</summary>
                <p>Run the following commands in your VS Code terminal (connected to your Pi via SSH):</p>
                <div class="code-block">
                  <pre><code>sudo apt update
          sudo apt install -y python3-full python3-pip python3-venv</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üß™ Step 2: Create a Virtual Environment</summary>
                <ol>
                  <li>Open the VS Code terminal connected to your Pi.</li>
                  <li>Create and enter a project folder:</li>
                  <div class="code-block">
                    <pre><code>mkdir -p ~/my_project
          cd ~/my_project</code></pre>
                  </div>
                  <li>Create a virtual environment named <code>venv</code>:</li>
                  <div class="code-block">
                    <pre><code>python3 -m venv venv</code></pre>
                  </div>
                  <li>Activate the virtual environment:</li>
                  <div class="code-block">
                    <pre><code>source venv/bin/activate</code></pre>
                  </div>
                  <li>Your terminal prompt should now show <code>(venv)</code></li>
                </ol>
              </details>
          
              <details>
                <summary>üì¶ Step 3: Install Python Packages</summary>
                <p>You can now safely install any Python package:</p>
                <div class="code-block">
                  <pre><code>pip install RPLCD
          pip install numpy
          pip install flask</code></pre>
                </div>
              </details>
          
              <details>
                <summary>‚ñ∂Ô∏è Step 4: Save and Run Python Code</summary>
                <ol>
                  <li>Use the VS Code file explorer to create a new file like <code>main.py</code> in <code>~/my_project</code>.</li>
                  <li>Write your Python code and save it.</li>
                  <li>In the terminal, make sure you're in the project folder and the virtual environment is activated:</li>
                  <div class="code-block">
                    <pre><code>cd ~/my_project
          source venv/bin/activate
          python main.py</code></pre>
                  </div>
                </ol>
              </details>
          
              <details>
                <summary>üö™ Step 5: Leave and Re-enter the Virtual Environment</summary>
                <h4>To leave:</h4>
                <div class="code-block">
                  <pre><code>deactivate</code></pre>
                </div>
                <h4>To re-enter later:</h4>
                <div class="code-block">
                  <pre><code>cd ~/my_project
          source venv/bin/activate</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üßΩ Terminal Quick Tips</summary>
                <ul>
                  <li><strong>Navigate to folder:</strong> <code>cd ~/my_project</code></li>
                  <li><strong>Create folder:</strong> <code>mkdir folder_name</code></li>
                  <li><strong>Activate venv:</strong> <code>source venv/bin/activate</code></li>
                  <li><strong>Deactivate venv:</strong> <code>deactivate</code></li>
                  <li><strong>Run script:</strong> <code>python filename.py</code></li>
                </ul>
              </details>
          
              <div class="tip-box">
                <strong>üí° Tip:</strong> To share your setup, use a <code>requirements.txt</code> file:
                <div class="code-block">
                  <pre><code>RPLCD
          RPi.GPIO
          flask</code></pre>
                </div>
                Then install with:
                <div class="code-block">
                  <pre><code>pip install -r requirements.txt</code></pre>
                </div>
              </div>
            </details>
          </section>
          
          <section class="card">
            <details>
              <summary>üìè Ultrasonic Sensor (HC-SR04)</summary>
              <p>
                The HC-SR04 is an ultrasonic distance sensor that uses sound waves to measure distance. It sends a 40 kHz pulse via the TRIG pin and listens for the echo using the ECHO pin.
              </p>
          
              <p>
                Distance is computed using the time delay of the echo using:
              </p>
              <div class="code-block"><code>distance (cm) = time (seconds) √ó 17150</code></div>
          
              <ul>
                <li><strong>TRIG:</strong> Sends 10Œºs pulse to start measurement</li>
                <li><strong>ECHO:</strong> Returns HIGH for the time it takes the sound to bounce back</li>
              </ul>
          
              <h4>üìâ Voltage Divider Requirement</h4>
              <div class="tip-box">
                <strong>Why a Voltage Divider?</strong><br>
                The HC-SR04‚Äôs <strong>ECHO</strong> pin outputs 5V, but the Raspberry Pi GPIO expects 3.3V max.<br>
                A voltage divider with two resistors safely drops the 5V to ~3.3V to protect the Pi.
              </div>
          
              <p><strong>Voltage Divider Formula:</strong></p>
              <div class="code-block"><code>Vout = Vin √ó (R2 / (R1 + R2))</code></div>
              <ul>
                <li><strong>Vin</strong> = 5V (ECHO signal)</li>
                <li><strong>R1</strong> = 2kŒ© (connected between ECHO and Pi input)</li>
                <li><strong>R2</strong> = 1kŒ© (connected between Pi input and GND)</li>
              </ul>
              <p>
                <strong>Calculation:</strong><br>
                Vout = 5V √ó (1k / (2k + 1k)) = 5V √ó (1/3) ‚âà 1.67V
              </p>
              <p>
                This math is backwards. To get 3.3V from 5V:<br>
                Use R1 = 1kŒ©, R2 = 2kŒ© ‚Üí Vout = 5V √ó (2 / (1 + 2)) = 5V √ó 0.666 = 3.33V ‚úÖ
              </p>
          
              <details>
                <summary>üß∞ Breadboard Wiring Example</summary>
                <div style="text-align: center;">
                  <img src="media/ultrasonic-breadboard.png" alt="Ultrasonic sensor with voltage divider on breadboard" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
                </div>
                </details>
                <details>

                  <summary>üîÅ Version 1: Single Reading (No Averaging)</summary>
                  <div class="code-block">
                    <pre><code class="language-python">import RPi.GPIO as GPIO      # Import GPIO library to control Raspberry Pi pins
                import time                  # Import time library for delays and timing
                
                TRIG = 5                     # Define GPIO pin 5 as the trigger pin
                ECHO = 6                     # Define GPIO pin 6 as the echo pin
                
                GPIO.setmode(GPIO.BCM)       # Use BCM pin numbering (GPIO numbers instead of board numbers)
                GPIO.setwarnings(False)      # Disable GPIO warnings (prevents duplicate warning messages)
                GPIO.setup(TRIG, GPIO.OUT)   # Set TRIG pin as output to send ultrasonic pulse
                GPIO.setup(ECHO, GPIO.IN)    # Set ECHO pin as input to receive echo signal
                
                def get_distance():
                    GPIO.output(TRIG, True)       # Send a high pulse (start signal)
                    time.sleep(0.00001)           # Wait for 10 microseconds (pulse duration)
                    GPIO.output(TRIG, False)      # Turn off the trigger (pulse end)
                
                    while GPIO.input(ECHO) == 0:  # Wait until echo signal goes high
                        pulse_start = time.time() # Record the start time
                
                    while GPIO.input(ECHO) == 1:  # Wait until echo signal goes low
                        pulse_end = time.time()   # Record the end time
                
                    # Calculate distance: (time √ó speed of sound) / 2
                    return round((pulse_end - pulse_start) * 17150, 2)  # Return distance in cm, rounded to 2 decimal places
                
                try:
                    while True:  # Infinite loop to continuously measure distance
                        print(f"Distance: {get_distance()} cm")  # Display measured distance
                        time.sleep(1)  # Wait 1 second before the next measurement
                except KeyboardInterrupt:
                    GPIO.cleanup()  # Reset all GPIO pins to safe state when exiting</code></pre>
                  </div>
                </details>
                
                <details>
                  <summary>üìä Version 2: Averaged Readings</summary>
                  <div class="code-block">
                    <pre><code class="language-python">import RPi.GPIO as GPIO        # Import library to control Raspberry Pi GPIO pins
                import time                    # Import time module for timing and delays
                
                # GPIO pins (BCM numbering)
                TRIG = 23                      # TRIG pin connected to GPIO 23
                ECHO = 24                      # ECHO pin connected to GPIO 24
                
                # Setup
                GPIO.setmode(GPIO.BCM)         # Use Broadcom (BCM) pin numbering
                GPIO.setwarnings(False)        # Disable GPIO warnings
                GPIO.setup(TRIG, GPIO.OUT)     # Set TRIG pin as an output
                GPIO.setup(ECHO, GPIO.IN)      # Set ECHO pin as an input
                
                def get_distance():
                    """Get a single distance measurement from the ultrasonic sensor."""
                    GPIO.output(TRIG, True)           # Send HIGH pulse to trigger the sensor
                    time.sleep(0.00001)               # Wait 10 microseconds
                    GPIO.output(TRIG, False)          # Set TRIG to LOW
                
                    timeout = time.time() + 1         # Timeout to prevent getting stuck in loop
                    while GPIO.input(ECHO) == 0:      # Wait for ECHO to go HIGH
                        if time.time() > timeout:     # Exit if timeout is reached
                            return None
                    pulse_start = time.time()         # Record start time of echo pulse
                
                    timeout = time.time() + 1         # Reset timeout
                    while GPIO.input(ECHO) == 1:      # Wait for ECHO to go LOW
                        if time.time() > timeout:     # Exit if timeout is reached
                            return None
                    pulse_end = time.time()           # Record end time of echo pulse
                
                    pulse_duration = pulse_end - pulse_start             # Calculate duration of the echo pulse
                    distance = pulse_duration * 17150                    # Convert time to distance in cm
                    return round(distance, 2)                            # Return rounded distance
                
                def get_average_distance(samples=5, delay=0.05):
                    """Get average of multiple distance readings."""
                    readings = []                                       # List to store valid readings
                    for _ in range(samples):                            # Loop to take multiple readings
                        dist = get_distance()                           # Take a single measurement
                        if dist is not None:                            # Only store if valid
                            readings.append(dist)
                        time.sleep(delay)                               # Wait briefly between readings
                
                    if readings:                                        # If we got valid readings
                        average = round(sum(readings) / len(readings), 2)  # Compute average
                        return average
                    else:
                        return None                                     # Return None if all readings failed
                
                try:
                    while True:                                         # Main loop
                        avg_distance = get_average_distance(samples=5)  # Get average distance over 5 samples
                        if avg_distance is not None:
                            print(f"Average Distance: {avg_distance} cm")  # Print average distance
                        else:
                            print("Failed to read distance")               # Fallback if no valid reading
                        time.sleep(1)                                     # Delay before next reading
                
                except KeyboardInterrupt:
                    print("\nMeasurement stopped by user")               # Graceful shutdown message
                    GPIO.cleanup()                                       # Reset GPIO pins to safe state</code></pre>
                  </div>
                </details>
            <div class="tip-box">
              <strong>üí° Tip:</strong> If you‚Äôre getting ‚Äú0.0 cm‚Äù or ‚ÄúNone‚Äù, double-check wiring and power ‚Äî make sure VCC is 5V and GND is solid.
            </div>
          </section>
          
</section>
    <section class="card">
      <details>
        <summary>üì∫ LCD Display (1602)</summary>
        <ul>
          <li>RS ‚Üí GPIO 25</li>
          <li>E ‚Üí GPIO 24</li>
          <li>D4‚ÄìD7 ‚Üí GPIO 23, 17, 18, 22</li>
        </ul>
        <div class="code-block"><code>import time
import RPi.GPIO as GPIO
from RPLCD import CharLCD

# GPIO setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# LCD pin config (using 4-bit mode)
lcd = CharLCD(cols=16, rows=2, pin_rs=25, pin_e=24,
              pins_data=[23, 17, 18, 22],
              numbering_mode=GPIO.BCM)

try:
    lcd.clear()
    lcd.write_string("LCD is working!")
    time.sleep(2)

    counter = 0
    while True:
        lcd.clear()
        lcd.write_string(f"Count: {counter}")
        counter += 1
        time.sleep(1)

except KeyboardInterrupt:
    lcd.clear()
    GPIO.cleanup()</code></div>
      </details>
    </section>

    <section class="card">
      <details>
        <summary>üì∑ ArduCam with Picamera2</summary>
        <div class="code-block"><code>sudo apt install -y libcamera-dev libopencv-dev</code></div>
        <div class="code-block"><code>from picamera2 import Picamera2
import cv2

picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}))
picam2.start()

while True:
    frame = picam2.capture_array()
    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) == ord('q'):
        break

picam2.stop()
cv2.destroyAllWindows()</code></div>
      </details>
    </section>
  </main>

  <aside style="position: absolute; right: 10px; top: 100px; width: 220px;">
    <h3>üîå GPIO Reference</h3>
    <img src="media/gpio-diagram.png" alt="GPIO Pinout Reference" style="width: 100%; border-radius: 8px;" />
  </aside>

  <section class="qr-section">
    <h3>üì± Quick Access</h3>
    <p>Scan this QR code to return to the LiDAR Car Project website.</p>
    <img src="media/QRcode.jpg" alt="QR code to project website" class="qr-code" />
  </section>

  <footer>
    <p>¬© 2025 Connor Reagan, Hugo Acevedo, Dhruveen Sheth</p>
  </footer>

  <script src="js/main.js"></script>
</body>
</html>