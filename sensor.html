<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensor Setup Guide</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    aside img {
      width: 100%;
      max-width: 300px; /* Increase size for better visibility */
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Setup Guide</h1>
    <nav>
      <a href="index.html">Home</a>
      <a href="parts.html">Parts List</a>
      <a href="sensor.html">Sensor Setup</a>
      <a href="lidar.html">LiDAR Car</a>
    </nav>
    <button class="toggle-dark-btn" onclick="toggleDarkMode()">üåô Toggle Dark Mode</button>
  </header>

  <main>
    <section class="card">
      <details>
        <summary>üìã Overview & Setup</summary>
        <p>This guide walks you through building a robust, multi-sensor demo system using a Raspberry Pi 4B running Raspberry Pi OS. Each component is tested individually and then combined into one working system. This document is written to be accessible for beginners, complete with fallback advice and troubleshooting context.</p>
        <h3>Hardware Components</h3>
        <ul>
          <li>Ultrasonic Sensor (HC-SR04)</li>
          <li>LCD Display (1602 Parallel)</li>
          <li>ArduCam Camera Module (IMX708 with PiCamera2)</li>
        </ul>
        <h3>You‚Äôll learn:</h3>
        <ul>
          <li>GPIO wiring and hardware setup</li>
          <li>Library installation</li>
          <li>Full commented Python scripts</li>
          <li>How to use the terminal for testing</li>
          <li>How to troubleshoot common issues</li>
        </ul>
      </details>
    </section>
    <section class="card">
      <details>
        <summary>üçì Raspberry Pi Setup</summary>
    
        <h3>üì¶ What You Need</h3>
        <ul>
          <li>Raspberry Pi 4B (or 3B+)</li>
          <li>MicroSD Card (16GB or more, Class 10 recommended)</li>
          <li>MicroSD Card Reader</li>
          <li>Power Supply (5V 3A)</li>
          <li>HDMI Monitor, USB Keyboard and Mouse (for first-time setup)</li>
        </ul>
    
        <details>
          <summary>üñ•Ô∏è Step 1: Install Raspberry Pi OS</summary>
          <ol>
            <li>Download and install <a href="https://www.raspberrypi.com/software/" target="_blank">Raspberry Pi Imager</a> on your PC.</li>
            <li>Insert the SD card into your reader.</li>
            <li>Launch the Imager, select:
              <ul>
                <li><strong>OS:</strong> Raspberry Pi OS (64-bit)</li>
                <li><strong>Storage:</strong> Your SD card</li>
              </ul>
            </li>
            <li>Click "Next", enable SSH (if offered), and set username/password.</li>
            <li>Click "Write" and wait for it to finish.</li>
          </ol>
        
          <h4>‚ö†Ô∏è OS Customization Warning</h4>
          <p>After you click <strong>Next</strong> or <strong>Write</strong>, you may see a pop-up like this:</p>
        
          <div style="text-align: center;">
            <img src="media/os-customisation-warning.png" alt="OS Customisation Prompt" style="max-width: 600px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
          </div>
        
          <p>
            When this screen appears, click the <strong style="color: crimson;">NO</strong> button.
            <br />
            Do <em>not</em> apply OS customization unless you're preconfiguring advanced settings.
          </p>
        
          <div class="tip-box">
            <strong>üí° Tip:</strong> Clicking "NO" ensures a clean Raspberry Pi OS install for first-time setup.
          </div>
        
          <details>
            <summary>üñºÔ∏è Raspberry Pi Imager Screenshots</summary>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
              <div>
                <h4 style="text-align: center;">macOS</h4>
                <img src="media/imager-mac.png" alt="Raspberry Pi Imager on macOS" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
              <div>
                <h4 style="text-align: center;">Windows</h4>
                <img src="media/imager-win.png" alt="Raspberry Pi Imager on Windows" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
            </div>
          </details>
        </details>
        
        <details>
          <summary>‚öôÔ∏è Step 2: First Boot Setup</summary>
          <ol>
            <li>Insert SD card into the Pi and power it on.</li>
            <li>Follow the on-screen wizard to set up Wi-Fi and localization.</li>
            <li>Open Terminal and run system updates:</li>
          </ol>
          <div class="code-block">
            <pre><code>sudo apt update
        sudo apt upgrade -y
        sudo reboot</code></pre>
        </details>
          <details>
              <summary>üîß Part 3: Remote Access & Development Setup</summary>
              <details>
                <summary>üìÖ Step 1: Download and Install VS Code</summary>
                <ol>
                  <li>Go to <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> and download the version for your OS (Windows, macOS, or Linux).</li>
                  <li>Install it using the standard installer.</li>
                  <li>Launch VS Code and open the Extensions tab (left sidebar).</li>
                  <li>Search for and install the extension called <strong>"Remote - SSH"</strong>.</li>
                </ol>
              </details>
              <details>
                <summary>üåê Step 2: Set Up Remote Access Options</summary>
                <h4>üñ•Ô∏è Option A: Tailscale</h4>
                <p><strong>Tailscale</strong> is a secure mesh VPN that connects your devices together into a private network using WireGuard.</p>
          
                <h5>üíª On Your Computer:</h5>
                <ol>
                  <li>Visit <a href="https://tailscale.com/download" target="_blank">tailscale.com/download</a> and install Tailscale.</li>
                  <li>Sign in using GitHub, Google, or Microsoft account.</li>
                  <li>Click <strong>"Enable Tailscale"</strong> to activate the virtual network.</li>
                </ol>
          
                <h5>üçì On Your Raspberry Pi:</h5>
                <div class="code-block">
                  <pre><code>curl -fsSL https://tailscale.com/install.sh | sh
          sudo tailscale up</code></pre>
                </div>
                <p>Log in via browser when prompted. The Pi will appear in your Tailscale dashboard with a private IP (e.g., <code>100.101.102.103</code>).</p>
          
                <h4>üåê Option B: Raspberry Pi Connect</h4>
                <p><strong>Raspberry Pi Connect</strong> offers browser-based GUI and terminal access. Ideal for light remote control.</p>
                <ol>
                  <li>Visit <a href="https://connect.raspberrypi.com/devices" target="_blank">connect.raspberrypi.com/devices</a>.</li>
                  <li>Log into your Raspberry Pi account.</li>
                  <li>Register your Pi using Raspberry Pi Imager or by installing the Connect package.</li>
                  <li>Once linked, you can access your Pi's desktop or terminal directly in your browser.</li>
                </ol>
              </details>
          
              <details>
                <summary>üîê Step 3: Connect via VS Code (SSH)</summary>
                <ol>
                  <li>In VS Code, press <kbd>Cmd/Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd>.</li>
                  <li>Select <strong>Remote-SSH: Connect to Host</strong>.</li>
                  <li>Enter the Pi's Tailscale IP like:
                    <div class="code-block"><code>pi@100.101.102.103</code></div>
                  </li>
                  <li>Authenticate with your Pi's password.</li>
                  <li>You're now working directly on the Pi through VS Code with full file system access.</li>
                </ol>
          
                <h3>ü§∫ Which Should You Use?</h3>
                <div class="tip-box">
                  <strong>üîß Use VS Code with Tailscale if you:</strong>
                  <ul>
                    <li>Need to write or edit code (Python, HTML, etc.)</li>
                    <li>Want terminal + Git + live development tools</li>
                    <li>Prefer using an IDE over a browser</li>
                  </ul>
                </div>
                <div class="tip-box">
                  <strong>üåê Use Raspberry Pi Connect if you:</strong>
                  <ul>
                    <li>Need quick GUI access from any device</li>
                    <li>Don't want to install VS Code or set up SSH</li>
                    <li>Are supporting users who just need to check or reboot the Pi remotely</li>
                  </ul>
                </div>
                <p><strong>Pro Tip:</strong> You can use both! Use Connect for quick GUI tweaks, and Tailscale+SSH for serious development work.</p>
              </details>
            </details>
          </section>
    

          <section class="card">
            <details>
              <summary>üìè Ultrasonic Sensor (HC-SR04)</summary>
          
              <p>
                The HC-SR04 is an ultrasonic distance sensor that uses sound waves to measure distance. It sends a 40 kHz pulse via the TRIG pin and listens for the echo using the ECHO pin.
              </p>
          
              <p>
                Distance is computed using the time delay of the echo using:
              </p>
              <div class="code-block"><code>distance (cm) = time (seconds) √ó 17150</code></div>
          
              <ul>
                <li><strong>TRIG:</strong> Sends 10Œºs pulse to start measurement</li>
                <li><strong>ECHO:</strong> Returns HIGH for the time it takes the sound to bounce back</li>
              </ul>
          
              <h4>üìâ Voltage Divider Requirement</h4>
              <div class="tip-box">
                <strong>Why a Voltage Divider?</strong><br>
                The HC-SR04‚Äôs <strong>ECHO</strong> pin outputs 5V, but the Raspberry Pi GPIO expects 3.3V max.<br>
                A voltage divider with two resistors safely drops the 5V to ~3.3V to protect the Pi.
              </div>
          
              <p><strong>Voltage Divider Formula:</strong></p>
              <div class="code-block"><code>Vout = Vin √ó (R2 / (R1 + R2))</code></div>
              <ul>
                <li><strong>Vin</strong> = 5V (ECHO signal)</li>
                <li><strong>R1</strong> = 2kŒ© (connected between ECHO and Pi input)</li>
                <li><strong>R2</strong> = 1kŒ© (connected between Pi input and GND)</li>
              </ul>
              <p>
                <strong>Calculation:</strong><br>
                Vout = 5V √ó (1k / (2k + 1k)) = 5V √ó (1/3) ‚âà 1.67V
              </p>
              <p>
                This math is backwards. To get 3.3V from 5V:<br>
                Use R1 = 1kŒ©, R2 = 2kŒ© ‚Üí Vout = 5V √ó (2 / (1 + 2)) = 5V √ó 0.666 = 3.33V ‚úÖ
              </p>
          
              <details>
                <summary>üß∞ Breadboard Wiring Example</summary>
                <div style="text-align: center;">
                  <img src="media/ultrasonic-breadboard.png" alt="Ultrasonic sensor with voltage divider on breadboard" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
                </div>
              </details>
          
              <h4>üîÅ Version 1: Single Reading (No Averaging)</h4>
              <details>
                <summary>üß™ Show Code</summary>
                <div class="code-block">
                  <pre><code class="language-python">import RPi.GPIO as GPIO
          import time
          
          TRIG = 5
          ECHO = 6
          
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)
          GPIO.setup(TRIG, GPIO.OUT)
          GPIO.setup(ECHO, GPIO.IN)
          
          def get_distance():
              GPIO.output(TRIG, True)
              time.sleep(0.00001)
              GPIO.output(TRIG, False)
          
              while GPIO.input(ECHO) == 0:
                  pulse_start = time.time()
              while GPIO.input(ECHO) == 1:
                  pulse_end = time.time()
          
              return round((pulse_end - pulse_start) * 17150, 2)
          
          try:
              while True:
                  print(f"Distance: {get_distance()} cm")
                  time.sleep(1)
          except KeyboardInterrupt:
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <h4>üìä Version 2: Averaged Readings</h4>
              <details>
                <summary>üìà Show Averaging Code</summary>
                <div class="code-block">
                  <pre><code class="language-python">import RPi.GPIO as GPIO
          import time
          
          TRIG = 23
          ECHO = 24
          
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)
          GPIO.setup(TRIG, GPIO.OUT)
          GPIO.setup(ECHO, GPIO.IN)
          
          def get_distance():
              GPIO.output(TRIG, True)
              time.sleep(0.00001)
              GPIO.output(TRIG, False)
          
              timeout = time.time() + 1
              while GPIO.input(ECHO) == 0:
                  if time.time() > timeout:
                      return None
              pulse_start = time.time()
          
              timeout = time.time() + 1
              while GPIO.input(ECHO) == 1:
                  if time.time() > timeout:
                      return None
              pulse_end = time.time()
          
              duration = pulse_end - pulse_start
              return round(duration * 17150, 2)
          
          def get_average_distance(samples=5, delay=0.05):
              readings = []
              for _ in range(samples):
                  dist = get_distance()
                  if dist is not None:
                      readings.append(dist)
                  time.sleep(delay)
              return round(sum(readings) / len(readings), 2) if readings else None
          
          try:
              while True:
                  avg = get_average_distance()
                  print(f"Avg Distance: {avg} cm" if avg else "Failed to read distance")
                  time.sleep(1)
          except KeyboardInterrupt:
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <h4>‚úÖ When to Use Each Version</h4>
              <ul>
                <li><strong>Version 1</strong>: For debugging or fast measurements</li>
                <li><strong>Version 2</strong>: For smoother, more stable readings</li>
              </ul>
            </details>
          
            <div class="tip-box">
              <strong>üí° Tip:</strong> If you‚Äôre getting ‚Äú0.0 cm‚Äù or ‚ÄúNone‚Äù, double-check wiring and power ‚Äî make sure VCC is 5V and GND is solid.
            </div>
          </section>
          
</section>
    <section class="card">
      <details>
        <summary>üì∫ LCD Display (1602)</summary>
        <ul>
          <li>RS ‚Üí GPIO 25</li>
          <li>E ‚Üí GPIO 24</li>
          <li>D4‚ÄìD7 ‚Üí GPIO 23, 17, 18, 22</li>
        </ul>
        <div class="code-block"><code>import time
import RPi.GPIO as GPIO
from RPLCD import CharLCD

# GPIO setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# LCD pin config (using 4-bit mode)
lcd = CharLCD(cols=16, rows=2, pin_rs=25, pin_e=24,
              pins_data=[23, 17, 18, 22],
              numbering_mode=GPIO.BCM)

try:
    lcd.clear()
    lcd.write_string("LCD is working!")
    time.sleep(2)

    counter = 0
    while True:
        lcd.clear()
        lcd.write_string(f"Count: {counter}")
        counter += 1
        time.sleep(1)

except KeyboardInterrupt:
    lcd.clear()
    GPIO.cleanup()</code></div>
      </details>
    </section>

    <section class="card">
      <details>
        <summary>üì∑ ArduCam with Picamera2</summary>
        <div class="code-block"><code>sudo apt install -y libcamera-dev libopencv-dev</code></div>
        <div class="code-block"><code>from picamera2 import Picamera2
import cv2

picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}))
picam2.start()

while True:
    frame = picam2.capture_array()
    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) == ord('q'):
        break

picam2.stop()
cv2.destroyAllWindows()</code></div>
      </details>
    </section>
  </main>

  <aside style="position: absolute; right: 10px; top: 100px; width: 220px;">
    <h3>üîå GPIO Reference</h3>
    <img src="media/gpio-diagram.png" alt="GPIO Pinout Reference" style="width: 100%; border-radius: 8px;" />
  </aside>

  <section class="qr-section">
    <h3>üì± Quick Access</h3>
    <p>Scan this QR code to return to the LiDAR Car Project website.</p>
    <img src="media/QRcode.jpg" alt="QR code to project website" class="qr-code" />
  </section>

  <footer>
    <p>¬© 2025 Connor Reagan, Hugo Acevedo, Dhruveen Sheth</p>
  </footer>

  <script src="js/main.js"></script>
</body>
</html>
