<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensor Setup Guide</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    aside img {
      width: 100%;
      max-width: 300px; /* Increase size for better visibility */
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Setup Guide</h1>
    <nav>
      <a href="index.html">Home</a>
      <a href="parts.html">Parts List</a>
      <a href="sensor.html">Sensor Setup</a>
      <a href="lidar.html">LiDAR Car</a>
    </nav>
    <button class="toggle-dark-btn" onclick="toggleDarkMode()">üåô Toggle Dark Mode</button>
  </header>

  <main>
    <section class="card">
      <details open>
        <summary>üìã Overview & Setup</summary>
        <p>This guide walks you through building a robust, multi-sensor demo system using a Raspberry Pi 4B running Raspberry Pi OS. Each component is tested individually and then combined into one working system. This document is written to be accessible for beginners, complete with fallback advice and troubleshooting context.</p>
        <h3>Hardware Components</h3>
        <ul>
          <li>Ultrasonic Sensor (HC-SR04)</li>
          <li>LCD Display (1602 Parallel)</li>
          <li>ArduCam Camera Module (IMX708 with PiCamera2)</li>
        </ul>
        <h3>You‚Äôll learn:</h3>
        <ul>
          <li>GPIO wiring and hardware setup</li>
          <li>Library installation</li>
          <li>Full commented Python scripts</li>
          <li>How to use the terminal for testing</li>
          <li>How to troubleshoot common issues</li>
        </ul>
      </details>
    </section>
    <section class="card">
      <details open>
        <summary>üçì Raspberry Pi Setup</summary>
    
        <h3>üì¶ What You Need</h3>
        <ul>
          <li>Raspberry Pi 4B (or 3B+)</li>
          <li>MicroSD Card (16GB or more, Class 10 recommended)</li>
          <li>MicroSD Card Reader</li>
          <li>Power Supply (5V 3A)</li>
          <li>HDMI Monitor, USB Keyboard and Mouse (for first-time setup)</li>
        </ul>
    
        <h3>üñ•Ô∏è Step 1: Install Raspberry Pi OS</h3>
        <ol>
          <li>Download and install <a href="https://www.raspberrypi.com/software/" target="_blank">Raspberry Pi Imager</a> on your PC.</li>
          <li>Insert the SD card into your reader.</li>
          <li>Launch the Imager, select:
            <ul>
              <li><strong>OS:</strong> Raspberry Pi OS (32-bit)</li>
              <li><strong>Storage:</strong> Your SD card</li>
            </ul>
          </li>
          <li>Click "Next", enable SSH (if offered), and set username/password.</li>
          <li>Click "Write" and wait for it to finish.</li>
        </ol>
    
        <img src="media/imager.jpg" alt="Raspberry Pi Imager setup" />
    
        <h3>‚öôÔ∏è Step 2: First Boot Setup</h3>
        <ol>
          <li>Insert SD card into the Pi and power it on.</li>
          <li>Follow the on-screen wizard to set up Wi-Fi and localization.</li>
          <li>Open Terminal and run system updates:</li>
        </ol>
    
        <div class="code-block">
          <pre><code>sudo apt update
    sudo apt upgrade -y
    sudo reboot</code></pre>
        </div>
    
        <img src="media/pi-setup.jpg" alt="Raspberry Pi desktop interface" />
    
        <h3>üåê Step 3: Remote Access with Tailscale (Optional)</h3>
        <p>If you want to access your Pi from any device securely:</p>
        <ol>
          <li>Run the following in Terminal:</li>
        </ol>
        <div class="code-block">
          <pre><code>curl -fsSL https://tailscale.com/install.sh | sh
    sudo tailscale up</code></pre>
        </div>
        <p>Log in via browser when prompted. Now you can SSH into the Pi from anywhere on your network.</p>
    
        <img src="media/tailscale-login.jpg" alt="Tailscale login browser screen" />
    
        <div class="tip-box">
          <strong>üí° Tip:</strong> You can also use <strong>Raspberry Pi Connect</strong> (in Imager) for browser-based remote access.
        </div>
      </details>
    </section>
    

    <section class="card">
      <details>
        <summary>üìè Ultrasonic Sensor (HC-SR04)</summary>
        <p>
          The HC-SR04 is an ultrasonic distance sensor that uses sound waves to measure how far away an object is. It works by emitting a very short ultrasonic pulse (at 40 kHz) from its "TRIG" pin, which bounces off nearby objects and returns to the "ECHO" pin. The time it takes for the echo to return is directly proportional to the distance of the object.
        </p>
        
        <p>
          Internally, it performs what's called "Time of Flight" measurement ‚Äî it records how long the sound takes to go out, bounce off an object, and come back. This time is then converted into distance using the formula:
        </p>
        
        <div class="code-block"><code>distance (cm) = time (seconds) √ó 17150</code></div>
        
        <ul>
          <li><strong>TRIG pin</strong> ‚Äî Sends out a 10¬µs HIGH pulse to start the measurement.</li>
          <li><strong>ECHO pin</strong> ‚Äî Goes HIGH as soon as the echo is detected and LOW when it's done. The time this pin stays HIGH is the duration of the echo travel.</li>
        </ul>
        
        <h4>üß† When to Use an Ultrasonic Sensor</h4>
        <p>
          Ultrasonic sensors are great for non-contact distance measurement in environments where light sensors (like infrared) may fail. They‚Äôre commonly used in:
        </p>
        <ul>
          <li>Obstacle detection and avoidance (robots, drones, cars)</li>
          <li>Distance measurement in automation or industrial settings</li>
          <li>Liquid level sensing in tanks</li>
          <li>Basic object detection for prototyping (e.g., motion-triggered lights or counters)</li>
        </ul>
        
        <p>
          Use the HC-SR04 when you need a cost-effective and reliable way to measure distances between ~2 cm and 400 cm in indoor or semi-controlled environments. It performs best on flat, solid surfaces like walls, doors, or boxes.
        </p>
        <p>
          üìÑ <a href="https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf" target="_blank">Download HC-SR04 Datasheet (PDF)</a>
        </p>
        
        <h4>üîÅ Version 1: Single Reading (No Averaging)</h4>
        <div class="code-block">
          <pre><code class="language-python">import RPi.GPIO as GPIO      # Import GPIO library to control Raspberry Pi pins
import time                  # Import time library for delays and timing

TRIG = 5                     # Define GPIO pin 5 as the trigger pin
ECHO = 6                     # Define GPIO pin 6 as the echo pin

GPIO.setmode(GPIO.BCM)       # Use BCM pin numbering (GPIO numbers instead of board numbers)
GPIO.setwarnings(False)      # Disable GPIO warnings (prevents duplicate warning messages)
GPIO.setup(TRIG, GPIO.OUT)   # Set TRIG pin as output to send ultrasonic pulse
GPIO.setup(ECHO, GPIO.IN)    # Set ECHO pin as input to receive echo signal

def get_distance():
    GPIO.output(TRIG, True)       # Send a high pulse (start signal)
    time.sleep(0.00001)           # Wait for 10 microseconds (pulse duration)
    GPIO.output(TRIG, False)      # Turn off the trigger (pulse end)

    while GPIO.input(ECHO) == 0:  # Wait until echo signal goes high
        pulse_start = time.time() # Record the start time

    while GPIO.input(ECHO) == 1:  # Wait until echo signal goes low
        pulse_end = time.time()   # Record the end time

    # Calculate distance: (time √ó speed of sound) / 2
    return round((pulse_end - pulse_start) * 17150, 2)  # Return distance in cm, rounded to 2 decimal places

try:
    while True:  # Infinite loop to continuously measure distance
        print(f"Distance: {get_distance()} cm")  # Display measured distance
        time.sleep(1)  # Wait 1 second before the next measurement
except KeyboardInterrupt:
    GPIO.cleanup()  # Reset all GPIO pins to safe state when exiting
  </code></pre>
  </div>

        <h4>üìä Version 2: Averaged Readings</h4>
        <div class="code-block">
        <pre><code>import RPi.GPIO as GPIO        # Import library to control Raspberry Pi GPIO pins
          import time                    # Import time module for timing and delays
          
          # GPIO pins (BCM numbering)
          TRIG = 23                      # TRIG pin connected to GPIO 23
          ECHO = 24                      # ECHO pin connected to GPIO 24
          
          # Setup
          GPIO.setmode(GPIO.BCM)         # Use Broadcom (BCM) pin numbering
          GPIO.setwarnings(False)        # Disable GPIO warnings
          GPIO.setup(TRIG, GPIO.OUT)     # Set TRIG pin as an output
          GPIO.setup(ECHO, GPIO.IN)      # Set ECHO pin as an input
          
          def get_distance():
              """Get a single distance measurement from the ultrasonic sensor."""
              GPIO.output(TRIG, True)           # Send HIGH pulse to trigger the sensor
              time.sleep(0.00001)               # Wait 10 microseconds
              GPIO.output(TRIG, False)          # Set TRIG to LOW
          
              timeout = time.time() + 1         # Timeout to prevent getting stuck in loop
              while GPIO.input(ECHO) == 0:      # Wait for ECHO to go HIGH
                  if time.time() > timeout:     # Exit if timeout is reached
                      return None
              pulse_start = time.time()         # Record start time of echo pulse
          
              timeout = time.time() + 1         # Reset timeout
              while GPIO.input(ECHO) == 1:      # Wait for ECHO to go LOW
                  if time.time() > timeout:     # Exit if timeout is reached
                      return None
              pulse_end = time.time()           # Record end time of echo pulse
          
              pulse_duration = pulse_end - pulse_start             # Calculate duration of the echo pulse
              distance = pulse_duration * 17150                    # Convert time to distance in cm
              return round(distance, 2)                            # Return rounded distance
          
          def get_average_distance(samples=5, delay=0.05):
              """Get average of multiple distance readings."""
              readings = []                                       # List to store valid readings
              for _ in range(samples):                            # Loop to take multiple readings
                  dist = get_distance()                           # Take a single measurement
                  if dist is not None:                            # Only store if valid
                      readings.append(dist)
                  time.sleep(delay)                               # Wait briefly between readings
          
              if readings:                                        # If we got valid readings
                  average = round(sum(readings) / len(readings), 2)  # Compute average
                  return average
              else:
                  return None                                     # Return None if all readings failed
          
          try:
              while True:                                         # Main loop
                  avg_distance = get_average_distance(samples=5)  # Get average distance over 5 samples
                  if avg_distance is not None:
                      print(f"Average Distance: {avg_distance} cm")  # Print average distance
                  else:
                      print("Failed to read distance")               # Fallback if no valid reading
                  time.sleep(1)                                     # Delay before next reading
          
          except KeyboardInterrupt:
              print("\nMeasurement stopped by user")               # Graceful shutdown message
              GPIO.cleanup()                                       # Reset GPIO pins to safe state
            </code></pre>
       </div>
    <h4>‚úÖ When to Use Each Version</h4>
    <ul>
      <li><strong>Version 1</strong>: For rapid readings, simple debugging, or low-latency needs.</li>
      <li><strong>Version 2</strong>: For smoother output when sensor noise or jitter is noticeable.</li>
    </ul>
  </details>
  <div class="tip-box">
    <strong>üí° Tip:</strong> If you consistently get a distance of ‚Äú0.0 cm‚Äù or ‚ÄúNone‚Äù, double-check the wiring, and ensure the sensor has at least 5V and a good ground.
  </div>
  
</section>
    <section class="card">
      <details>
        <summary>üì∫ LCD Display (1602)</summary>
        <ul>
          <li>RS ‚Üí GPIO 25</li>
          <li>E ‚Üí GPIO 24</li>
          <li>D4‚ÄìD7 ‚Üí GPIO 23, 17, 18, 22</li>
        </ul>
        <div class="code-block"><code>import time
import RPi.GPIO as GPIO
from RPLCD import CharLCD

# GPIO setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# LCD pin config (using 4-bit mode)
lcd = CharLCD(cols=16, rows=2, pin_rs=25, pin_e=24,
              pins_data=[23, 17, 18, 22],
              numbering_mode=GPIO.BCM)

try:
    lcd.clear()
    lcd.write_string("LCD is working!")
    time.sleep(2)

    counter = 0
    while True:
        lcd.clear()
        lcd.write_string(f"Count: {counter}")
        counter += 1
        time.sleep(1)

except KeyboardInterrupt:
    lcd.clear()
    GPIO.cleanup()</code></div>
      </details>
    </section>

    <section class="card">
      <details>
        <summary>üì∑ ArduCam with Picamera2</summary>
        <div class="code-block"><code>sudo apt install -y libcamera-dev libopencv-dev</code></div>
        <div class="code-block"><code>from picamera2 import Picamera2
import cv2

picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}))
picam2.start()

while True:
    frame = picam2.capture_array()
    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) == ord('q'):
        break

picam2.stop()
cv2.destroyAllWindows()</code></div>
      </details>
    </section>
  </main>

  <aside style="position: absolute; right: 10px; top: 100px; width: 220px;">
    <h3>üîå GPIO Reference</h3>
    <img src="media/gpio-diagram.png" alt="GPIO Pinout Reference" style="width: 100%; border-radius: 8px;" />
  </aside>

  <section class="qr-section">
    <h3>üì± Quick Access</h3>
    <p>Scan this QR code to return to the LiDAR Car Project website.</p>
    <img src="media/QRcode.jpg" alt="QR code to project website" class="qr-code" />
  </section>

  <footer>
    <p>¬© 2025 Connor Reagan, Hugo Acevedo, Dhruveen Sheth</p>
  </footer>

  <script src="js/main.js"></script>
</body>
</html>
