<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensor Setup Guide</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    aside img {
      width: 100%;
      max-width: 300px; /* Increase size for better visibility */
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Setup Guide</h1>
    <nav>
      <a href="index.html">Home</a>
      <a href="parts.html">Parts List</a>
      <a href="sensor.html">Sensor Setup</a>
      <a href="lidar.html">LiDAR Car</a>
    </nav>
    <button class="toggle-dark-btn" onclick="toggleDarkMode()">üåô Toggle Dark Mode</button>
  </header>

  <main>
    <section class="card">
      <details>
        <summary>üìã Overview & Setup</summary>
        <p>This guide walks you through building a robust, multi-sensor demo system using a Raspberry Pi 4B running Raspberry Pi OS. Each component is tested individually and then combined into one working system. This document is written to be accessible for beginners, complete with fallback advice and troubleshooting context.</p>
        <h3>Hardware Components</h3>
        <ul>
          <li>Ultrasonic Sensor (HC-SR04)</li>
          <li>LCD Display (1602 Parallel)</li>
          <li>ArduCam Camera Module (IMX708 with PiCamera2)</li>
        </ul>
        <h3>You‚Äôll learn:</h3>
        <ul>
          <li>GPIO wiring and hardware setup</li>
          <li>Library installation</li>
          <li>Full commented Python scripts</li>
          <li>How to use the terminal for testing</li>
          <li>How to troubleshoot common issues</li>
        </ul>
      </details>
    </section>
    <section class="card">
      <details>
        <summary>üçì Raspberry Pi Setup</summary>
    
        <h3>üì¶ What You Need</h3>
        <ul>
          <li>Raspberry Pi 4B (or 3B+)</li>
          <li>MicroSD Card (16GB or more, Class 10 recommended)</li>
          <li>MicroSD Card Reader</li>
          <li>Power Supply (5V 3A)</li>
          <li>HDMI Monitor, USB Keyboard and Mouse (for first-time setup)</li>
        </ul>
    
        <details>
          <summary>üñ•Ô∏è Step 1: Install Raspberry Pi OS</summary>
          <ol>
            <li>Download and install <a href="https://www.raspberrypi.com/software/" target="_blank">Raspberry Pi Imager</a> on your PC.</li>
            <li>Insert the SD card into your reader.</li>
            <li>Launch the Imager, select:
              <ul>
                <li><strong>OS:</strong> Raspberry Pi OS (64-bit)</li>
                <li><strong>Storage:</strong> Your SD card</li>
              </ul>
            </li>
            <li>Click "Next", enable SSH (if offered), and set username/password.</li>
            <li>Click "Write" and wait for it to finish.</li>
          </ol>
        
          <h4>‚ö†Ô∏è OS Customization Warning</h4>
          <p>After you click <strong>Next</strong> or <strong>Write</strong>, you may see a pop-up like this:</p>
        
          <div style="text-align: center;">
            <img src="media/os-customisation-warning.png" alt="OS Customisation Prompt" style="max-width: 600px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
          </div>
        
          <p>
            When this screen appears, click the <strong style="color: crimson;">NO</strong> button.
            <br />
            Do <em>not</em> apply OS customization unless you're preconfiguring advanced settings.
          </p>
        
          <div class="tip-box">
            <strong>üí° Tip:</strong> Clicking "NO" ensures a clean Raspberry Pi OS install for first-time setup.
          </div>
        
          <details>
            <summary>üñºÔ∏è Raspberry Pi Imager Screenshots</summary>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
              <div>
                <h4 style="text-align: center;">macOS</h4>
                <img src="media/imager-mac.png" alt="Raspberry Pi Imager on macOS" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
              <div>
                <h4 style="text-align: center;">Windows</h4>
                <img src="media/imager-win.png" alt="Raspberry Pi Imager on Windows" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);" />
              </div>
            </div>
          </details>
        </details>
        <details>
          <summary>‚öôÔ∏è Step 2: First Boot Setup</summary>
          <ol>
            <li>Insert SD card into the Pi and power it on.</li>
            <li>Follow the on-screen wizard to set up Wi-Fi and localization.</li>
            <li>Open Terminal and run system updates:</li>
          </ol>
          <div class="code-block">
            <pre><code>sudo apt update
        sudo apt upgrade -y
        sudo reboot</code></pre>
        </details>
        <details>
          <summary>üîß Step 3: Remote Access & Development Setup</summary>
          <details>
            <summary>üóïÔ∏è Step 1: Download and Install VS Code</summary>
            <ol>
              <li>Go to <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> and download the version for your OS.</li>
              <li>Install it using the standard installer.</li>
              <li>Launch VS Code and open the Extensions tab.</li>
              <li>Search for and install the <strong>"Remote - SSH"</strong> extension.</li>
            </ol>
          </details>
        
          <details>
            <summary>üåê Step 2: Set Up Remote Access Options</summary>
            <h4>üñ•Ô∏è Option A: Tailscale</h4>
            <p><strong>Tailscale</strong> is a secure VPN using WireGuard.</p>
            <h5>üíª On Your Computer:</h5>
            <ol>
              <li>Visit <a href="https://tailscale.com/download" target="_blank">tailscale.com/download</a>.</li>
              <li>Install and sign in.</li>
              <li>Click <strong>"Enable Tailscale"</strong>.</li>
            </ol>
            <h5>üçì On Your Raspberry Pi:</h5>
            <pre><code>curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up</code></pre>
        
            <h4>üåê Option B: Raspberry Pi Connect</h4>
            <ol>
              <li>Visit <a href="https://connect.raspberrypi.com/devices" target="_blank">connect.raspberrypi.com/devices</a>.</li>
              <li>Log in and register your Pi.</li>
              <li>Use the web interface to access terminal or desktop.</li>
            </ol>
          </details>
        
          <details>
            <summary>üîê Step 3: Connect via VS Code (SSH)</summary>
            <ol>
              <li>In VS Code, press <kbd>Ctrl/Cmd + Shift + P</kbd>.</li>
              <li>Select <strong>Remote-SSH: Connect to Host</strong>.</li>
              <li>Enter <code>pi@YOUR_TAILSCALE_IP</code>.</li>
              <li>Authenticate and start working directly on the Pi.</li>
            </ol>
        
            <h3>ü§∫ Which Should You Use?</h3>
            <div class="tip-box">
              <strong>üîß Use VS Code with Tailscale if you:</strong>
              <ul>
                <li>Want terminal + Git + code editing</li>
                <li>Prefer an IDE</li>
              </ul>
            </div>
            <div class="tip-box">
              <strong>üåê Use Raspberry Pi Connect if you:</strong>
              <ul>
                <li>Want fast access from a browser</li>
                <li>Don‚Äôt need full development tools</li>
              </ul>
            </div>
          </details>
        
        </details>
        
          </section>
          <section class="card">
            <details>
              <summary>üêç Python Setup + Virtual Environment (General Use)</summary>
          
              <h3>üí° Why Use a Virtual Environment?</h3>
              <p>
                On Raspberry Pi OS (especially Bookworm and newer), the system Python is protected. If you try to install packages directly using <code>pip3</code>, you may get this error:
              </p>
              <div class="code-block">
                <pre><code>error: externally-managed-environment</code></pre>
              </div>
              <p>
                A virtual environment is an isolated Python environment that lets you install and manage packages like <code>RPLCD</code>, <code>numpy</code>, or <code>flask</code> without interfering with the system Python or requiring <code>sudo</code>.
              </p>
          
              <details>
                <summary>‚öôÔ∏è Step 1: Install Required Tools</summary>
                <p>Run the following commands in your VS Code terminal (connected to your Pi via SSH):</p>
                <div class="code-block">
                  <pre><code>sudo apt update
          sudo apt install -y python3-full python3-pip python3-venv</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üß™ Step 2: Create a Virtual Environment</summary>
                <ol>
                  <li>Open the VS Code terminal connected to your Pi.</li>
                  <li>Create and enter a project folder:</li>
                  <div class="code-block">
                    <pre><code>mkdir -p ~/my_project
          cd ~/my_project</code></pre>
                  </div>
                  <li>Create a virtual environment named <code>venv</code>:</li>
                  <div class="code-block">
                    <pre><code>python3 -m venv venv</code></pre>
                  </div>
                  <li>Activate the virtual environment:</li>
                  <div class="code-block">
                    <pre><code>source venv/bin/activate</code></pre>
                  </div>
                  <li>Your terminal prompt should now show <code>(venv)</code></li>
                </ol>
              </details>
          
              <details>
                <summary>üì¶ Step 3: Install Python Packages</summary>
                <p>You can now safely install any Python package:</p>
                <div class="code-block">
                  <pre><code>pip install RPLCD
          pip install numpy
          pip install flask</code></pre>
                </div>
              </details>
          
              <details>
                <summary>‚ñ∂Ô∏è Step 4: Save and Run Python Code</summary>
                <ol>
                  <li>In VS Code, go to the Explorer panel and click the folder <code>my_project</code>.</li>
                  <li>Right-click and choose <strong>New File</strong>. Name it <code>main.py</code>.</li>
                  <li>Write your Python code inside <code>main.py</code> and press <kbd>Ctrl + S</kbd> (or <kbd>Cmd + S</kbd> on Mac) to save.</li>
                  <li>
                    Saving a script in the virtual environment folder is <strong>not required</strong> and not recommended. 
                    Instead, just make sure you <strong>activate the virtual environment</strong> before running your script.
                  </li>
                  <li>In the terminal, run:
                    <div class="code-block">
                      <pre><code>cd ~/my_project
          source venv/bin/activate
          python main.py</code></pre>
                    </div>
                  </li>
                </ol>
                <div class="tip-box">
                  <strong>üí° Tip:</strong> The Python file can live anywhere in your project folder. The virtual environment handles the Python context ‚Äî no need to store code inside <code>venv/</code>.
                </div>
              </details>
          
              <details>
                <summary>üö™ Step 5: Leave and Re-enter the Virtual Environment</summary>
                <h4>To leave:</h4>
                <div class="code-block">
                  <pre><code>deactivate</code></pre>
                </div>
                <h4>To re-enter later:</h4>
                <div class="code-block">
                  <pre><code>cd ~/my_project
          source venv/bin/activate</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üßΩ Terminal Quick Tips</summary>
                <ul>
                  <li><strong>Navigate to folder:</strong> <code>cd ~/my_project</code></li>
                  <li><strong>Create folder:</strong> <code>mkdir folder_name</code></li>
                  <li><strong>Activate venv:</strong> <code>source venv/bin/activate</code></li>
                  <li><strong>Deactivate venv:</strong> <code>deactivate</code></li>
                  <li><strong>Run script:</strong> <code>python filename.py</code></li>
                </ul>
              </details>
          
              <div class="tip-box">
                <strong>üí° Tip:</strong> To share your setup, use a <code>requirements.txt</code> file:
                <div class="code-block">
                  <pre><code>RPLCD
          RPi.GPIO
          flask</code></pre>
                </div>
                Then install with:
                <div class="code-block">
                  <pre><code>pip install -r requirements.txt</code></pre>
                </div>
              </div>
            </details>
          </section>
          
          
          <section class="card">
            <details>
              <summary>üìè Ultrasonic Sensor (HC-SR04)</summary>
              <p>
                The HC-SR04 is an ultrasonic distance sensor that uses sound waves to measure distance. It sends a 40 kHz pulse via the TRIG pin and listens for the echo using the ECHO pin.
              </p>
          
              <p>
                Distance is computed using the time delay of the echo using:
              </p>
              <div class="code-block"><code>distance (cm) = time (seconds) √ó 17150</code></div>
          
              <ul>
                <li><strong>TRIG:</strong> Sends 10Œºs pulse to start measurement</li>
                <li><strong>ECHO:</strong> Returns HIGH for the time it takes the sound to bounce back</li>
              </ul>
          
              <h4>üìâ Voltage Divider Requirement</h4>
              <div class="tip-box">
                <strong>Why a Voltage Divider?</strong><br>
                The HC-SR04‚Äôs <strong>ECHO</strong> pin outputs 5V, but the Raspberry Pi GPIO expects 3.3V max.<br>
                A voltage divider with two resistors safely drops the 5V to ~3.3V to protect the Pi.
              </div>
          
              <p><strong>Voltage Divider Formula:</strong></p>
              <div class="code-block"><code>Vout = Vin √ó (R2 / (R1 + R2))</code></div>
              <ul>
                <li><strong>Vin</strong> = 5V (ECHO signal)</li>
                <li><strong>R1</strong> = 2kŒ© (connected between ECHO and Pi input)</li>
                <li><strong>R2</strong> = 1kŒ© (connected between Pi input and GND)</li>
              </ul>
              <p>
                <strong>Calculation:</strong><br>
                Vout = 5V √ó (1k / (2k + 1k)) = 5V √ó (1/3) ‚âà 1.67V
              </p>
              <p>
                This math is backwards. To get 3.3V from 5V:<br>
                Use R1 = 1kŒ©, R2 = 2kŒ© ‚Üí Vout = 5V √ó (2 / (1 + 2)) = 5V √ó 0.666 = 3.33V ‚úÖ
              </p>
          
              <details>
                <summary>üß∞ Breadboard Wiring Example</summary>
                <div style="text-align: center;">
                  <img src="media/ultrasonic-breadboard.png" alt="Ultrasonic sensor with voltage divider on breadboard" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
                </div>
              </details>
          
              <details>
                <summary>üîÅ Version 1: Single Reading (No Averaging)</summary>
                <p><strong>Note:</strong> Make sure to activate your virtual environment before running:</p>
                <div class="code-block"><pre><code>source ~/my_project/venv/bin/activate</code></pre></div>
                <div class="code-block">
                  <pre><code class="language-python">import RPi.GPIO as GPIO
          import time
          
          TRIG = 5  # Change this to match your wiring
          ECHO = 6  # Change this to match your wiring
          
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)
          GPIO.setup(TRIG, GPIO.OUT)
          GPIO.setup(ECHO, GPIO.IN)
          
          def get_distance():
              GPIO.output(TRIG, True)
              time.sleep(0.00001)
              GPIO.output(TRIG, False)
          
              while GPIO.input(ECHO) == 0:
                  pulse_start = time.time()
          
              while GPIO.input(ECHO) == 1:
                  pulse_end = time.time()
          
              return round((pulse_end - pulse_start) * 17150, 2)
          
          try:
              while True:
                  print(f"Distance: {get_distance()} cm")
                  time.sleep(1)
          except KeyboardInterrupt:
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üìä Version 2: Averaged Readings</summary>
                <p><strong>Note:</strong> Make sure to activate your virtual environment before running:</p>
                <div class="code-block"><pre><code>source ~/my_project/venv/bin/activate</code></pre></div>
                <p><strong>GPIO Pins used:</strong> TRIG = 23, ECHO = 24. Update these as needed to match your setup.</p>
                <div class="code-block">
                  <pre><code class="language-python">import RPi.GPIO as GPIO
          import time
          
          TRIG = 23  # Adjust as needed
          ECHO = 24  # Adjust as needed
          
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)
          GPIO.setup(TRIG, GPIO.OUT)
          GPIO.setup(ECHO, GPIO.IN)
          
          def get_distance():
              GPIO.output(TRIG, True)
              time.sleep(0.00001)
              GPIO.output(TRIG, False)
          
              timeout = time.time() + 1
              while GPIO.input(ECHO) == 0:
                  if time.time() > timeout:
                      return None
              pulse_start = time.time()
          
              timeout = time.time() + 1
              while GPIO.input(ECHO) == 1:
                  if time.time() > timeout:
                      return None
              pulse_end = time.time()
          
              pulse_duration = pulse_end - pulse_start
              distance = pulse_duration * 17150
              return round(distance, 2)
          
          def get_average_distance(samples=5, delay=0.05):
              readings = []
              for _ in range(samples):
                  dist = get_distance()
                  if dist is not None:
                      readings.append(dist)
                  time.sleep(delay)
              if readings:
                  return round(sum(readings) / len(readings), 2)
              else:
                  return None
          
          try:
              while True:
                  avg_distance = get_average_distance(samples=5)
                  if avg_distance is not None:
                      print(f"Average Distance: {avg_distance} cm")
                  else:
                      print("Failed to read distance")
                  time.sleep(1)
          except KeyboardInterrupt:
              print("\nMeasurement stopped by user")
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üíª Running from VS Code Terminal</summary>
                <ol>
                  <li>Make sure your file (e.g., <code>ultrasonic.py</code>) is saved in <code>~/my_project</code> or a similar folder.</li>
                  <li>In the VS Code terminal (SSH connected to Pi):</li>
                  <div class="code-block">
                    <pre><code>cd ~/my_project
          source venv/bin/activate
          python ultrasonic.py</code></pre>
                  </div>
                  <li>Use <code>deactivate</code> when you're done.</li>
                </ol>
              </details>
          
              <div class="tip-box">
                <strong>üí° Tip:</strong> If you're getting "0.0 cm" or "None", double-check wiring and power. Make sure:
                <ul>
                  <li>VCC is connected to 5V</li>
                  <li>GND is properly grounded</li>
                  <li>GPIO pins match what your code expects</li>
                  <li>Your virtual environment is activated before running</li>
                </ul>
              </div>
            </details>
          </section>
          
          <section class="card">
            <details>
              <summary>üì∫ LCD Display (1602)</summary>
              <p>
                The 1602 LCD is a basic alphanumeric display that shows up to 16 characters per line across 2 lines. It is ideal for Raspberry Pi projects where you want to display text like sensor readings, statuses, or debug messages without needing a full monitor.
              </p>
          
              <p><strong>How It Works:</strong> This display uses the HD44780 driver, which supports both 4-bit and 8-bit parallel communication. Using 4-bit mode reduces the GPIO pins required on the Raspberry Pi.
              </p>
          
              <ul>
                <li><strong>RS (Register Select):</strong> Chooses between command mode (e.g., clear screen) and character mode (writing text).</li>
                <li><strong>E (Enable):</strong> A rising edge on this pin tells the LCD to read RS and data lines.</li>
                <li><strong>D4‚ÄìD7:</strong> 4-bit data bus used to send characters or instructions.</li>
              </ul>
          
              <h4>üîå Wiring Overview</h4>
              <ul>
                <li><strong>RS ‚Üí</strong> GPIO 25</li>
                <li><strong>E ‚Üí</strong> GPIO 24</li>
                <li><strong>D4‚ÄìD7 ‚Üí</strong> GPIO 23, 17, 18, 22</li>
                <li><strong>RW ‚Üí</strong> GND (Write-only)</li>
                <li><strong>VSS/VDD ‚Üí</strong> GND / 5V</li>
                <li><strong>VO ‚Üí</strong> Middle pin of a 10kŒ© potentiometer to control contrast</li>
                <li><strong>A/K ‚Üí</strong> 5V / GND for backlight</li>
              </ul>
          
              <div class="tip-box">
                <strong>Why Use It?</strong>
                <ul>
                  <li>Displays info without needing a monitor</li>
                  <li>Very low power and inexpensive</li>
                  <li>Useful for portable or embedded projects</li>
                </ul>
              </div>
          
              <details>
                <summary>üíª Basic LCD Test Code</summary>
                <div class="code-block">
                  <pre><code class="language-python"># Import time for delays and RPi.GPIO for pin control
          import time
          import RPi.GPIO as GPIO
          from RPLCD import CharLCD
          
          # Set pin mode to BCM (Broadcom chip-specific pin numbering)
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)  # Prevent warning messages from previous runs
          
          # Initialize LCD with 4-bit mode using RPLCD library
          lcd = CharLCD(
              cols=16,                # 16 characters wide
              rows=2,                 # 2 rows tall
              pin_rs=25,              # Register Select pin connected to GPIO 25
              pin_e=24,               # Enable pin connected to GPIO 24
              pins_data=[23, 17, 18, 22],  # Data pins D4‚ÄìD7
              numbering_mode=GPIO.BCM # Use BCM pin numbering
          )
          
          try:
              lcd.clear()  # Clear any existing text
              lcd.write_string("LCD is working!")  # Initial test message
              time.sleep(2)
          
              counter = 0
              while True:
                  lcd.clear()  # Clear previous message
                  lcd.write_string(f"Count: {counter}")  # Display counter value
                  counter += 1
                  time.sleep(1)  # Wait 1 second before updating
          
          except KeyboardInterrupt:
              lcd.clear()  # Clear LCD on exit
              GPIO.cleanup()  # Clean up GPIO states</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üì° Display Ultrasonic Distance</summary>
                <div class="code-block">
                  <pre><code class="language-python">import RPi.GPIO as GPIO
          import time
          from RPLCD import CharLCD
          
          # Setup for ultrasonic sensor
          TRIG = 5  # GPIO pin connected to TRIG of sensor
          ECHO = 6  # GPIO pin connected to ECHO of sensor
          
          GPIO.setmode(GPIO.BCM)
          GPIO.setwarnings(False)
          GPIO.setup(TRIG, GPIO.OUT)
          GPIO.setup(ECHO, GPIO.IN)
          
          # Setup LCD display
          lcd = CharLCD(cols=16, rows=2, pin_rs=25, pin_e=24,
                        pins_data=[23, 17, 18, 22], numbering_mode=GPIO.BCM)
          
          def get_distance():
              GPIO.output(TRIG, True)  # Start ultrasonic pulse
              time.sleep(0.00001)      # 10 microsecond pulse
              GPIO.output(TRIG, False)
          
              while GPIO.input(ECHO) == 0:
                  pulse_start = time.time()
          
              while GPIO.input(ECHO) == 1:
                  pulse_end = time.time()
          
              pulse_duration = pulse_end - pulse_start
              distance = pulse_duration * 17150  # Speed of sound constant
              return round(distance, 2)
          
          try:
              while True:
                  distance = get_distance()
                  lcd.clear()
                  lcd.write_string(f"Dist: {distance} cm")
                  time.sleep(1)
          except KeyboardInterrupt:
              lcd.clear()
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <details>
                <summary>‚úçÔ∏è Custom Message Display</summary>
                <div class="code-block">
                  <pre><code class="language-python">from RPLCD import CharLCD
          import RPi.GPIO as GPIO
          import time
          
          # Setup for LCD
          GPIO.setmode(GPIO.BCM)
          lcd = CharLCD(cols=16, rows=2, pin_rs=25, pin_e=24,
                        pins_data=[23, 17, 18, 22], numbering_mode=GPIO.BCM)
          
          try:
              lcd.clear()
              lcd.write_string("Hello, World!")  # First message
              time.sleep(3)
          
              lcd.clear()
              lcd.write_string("Welcome to your\nProject Demo!")  # Second message with newline
              time.sleep(5)
          
          except KeyboardInterrupt:
              lcd.clear()
              GPIO.cleanup()</code></pre>
                </div>
              </details>
          
              <details>
                <summary>üß∞ Breadboard Wiring Example</summary>
                <div style="text-align: center;">
                  <img src="media/lcd-breadboard.png" alt="LCD 1602 with Raspberry Pi wiring diagram" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
                </div>
              </details>
            </details>
          </section>
    <section class="card">
      <details>
        <summary>üì∑ ArduCam with Picamera2</summary>
<p>
  The ArduCam IMX708 camera module connects to the Raspberry Pi using the CSI port and works with the <code>libcamera</code> stack and the <code>picamera2</code> library. It supports high-resolution video capture and is the same sensor used in the official Raspberry Pi Camera Module 3.
</p>

<p><strong>Why Use ArduCam IMX708 + Picamera2?</strong></p>
<ul>
  <li>Delivers high-resolution images and video up to 4608√ó2592</li>
  <li>Efficient CSI connection means high-speed streaming</li>
  <li>Compatible with libcamera and OpenCV for real-time computer vision</li>
</ul>

<h4>üõ†Ô∏è Hardware Setup Instructions</h4>
<ol>
  <li>Power off the Raspberry Pi completely.</li>
  <li>Insert the ribbon cable into the CSI port near the HDMI ports. Make sure the metal contacts face the HDMI side and that the clip is securely latched.</li>
  <li>Power on the Pi.</li>
</ol>

<h4>‚öôÔ∏è Enable the Camera</h4>
<ol>
  <li>Run <code>sudo nano /boot/firmware/config.txt</code></li>
  <li>Scroll to the bottom and add these two lines:
    <div class="code-block"><code>camera_auto_detect=0
dtoverlay=imx708</code></div>
  </li>
  <li>Save with <code>Ctrl + O</code>, then <code>Enter</code>, then <code>Ctrl + X</code>.</li>
  <li>Reboot: <code>sudo reboot</code></li>
</ol>

<h4>‚úÖ Test the Camera</h4>
<pre class="code-block"><code>libcamera-hello --list-cameras</code></pre>
<p>You should see:</p>
<div class="code-block"><code>Available cameras
-----------------
0 : imx708 [4608x2592 10-bit RGGB] (...)</code></div>

<h4>üì¶ Install Dependencies</h4>
<div class="code-block"><code>sudo apt install -y python3-picamera2 python3-opencv</code></div>

<h4>üíª Running the Camera with Python</h4>
<details>
  <summary>Live Preview Script</summary>
  <div class="code-block">
    <pre><code class="language-python">from picamera2 import Picamera2
import cv2

# Initialize camera
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}))
picam2.start()

# Show video preview in a window
while True:
    frame = picam2.capture_array()
    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) == ord('q'):
        break

picam2.stop()
cv2.destroyAllWindows()</code></pre>
  </div>
</details>

<h4>üîê Note: Use Raspberry Pi Connect or VS Code Remote</h4>
<p>
  Because the camera output opens a graphical window, you will need to be physically connected to a monitor or use <strong>Raspberry Pi Connect</strong> (official remote desktop by Raspberry Pi) or <strong>VNC Viewer</strong> to view the camera preview if you‚Äôre working remotely.
</p>

<details>
  <summary>üß∞ ArduCam CSI Cable Setup Image</summary>
  <div style="text-align: center;">
    <img src="media/arducam-csi-connection.png" alt="ArduCam connected to Raspberry Pi CSI port" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
  </div>
</details>

<details>
  <summary>üß∞ Wiring and Setup Notes</summary>
  <p>
    Make sure your camera is properly seated in the CSI port of the Raspberry Pi and enabled using <code>sudo raspi-config</code> under <strong>Interface Options</strong> ‚Üí <strong>Camera</strong>.
  </p>
  <ul>
    <li>Connect ArduCam to the <strong>CSI port</strong> near the HDMI ports</li>
    <li>Use the <strong>ribbon cable</strong> to connect and clamp it securely</li>
    <li>Ensure the camera is detected with <code>libcamera-hello</code></li>
  </ul>
  <div style="text-align: center;">
    <img src="media/arducam-csi-connection.png" alt="ArduCam connected to Raspberry Pi CSI port" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);" />
  </div>
</details>
</section>

<section class="card">
  <details open>
    <summary>üì¶ LCD + Ultrasonic Sensor + Camera Stream (Combo Build)</summary>
    <p>
      This integrated setup displays real-time distance measurements from an HC-SR04 ultrasonic sensor on a 1602 LCD and simultaneously shows a live video feed using the ArduCam IMX708 with the <code>picamera2</code> library.
    </p>

    <h4>üîå Wiring Overview</h4>
    <ul>
      <li><strong>Ultrasonic TRIG ‚Üí</strong> GPIO 5</li>
      <li><strong>Ultrasonic ECHO ‚Üí</strong> GPIO 6</li>
      <li><strong>LCD RS ‚Üí</strong> GPIO 25</li>
      <li><strong>LCD E ‚Üí</strong> GPIO 24</li>
      <li><strong>LCD D4-D7 ‚Üí</strong> GPIO 23, 17, 18, 22</li>
    </ul>

    <h4>üíª Full Python Code</h4>
    <details>
      <summary>üìú View Python Script</summary>
      <div class="code-block">
        <pre><code class="language-python"># === IMPORT LIBRARIES ===
import RPi.GPIO as GPIO        # Controls Raspberry Pi GPIO pins
import time                    # Used for time delays and timestamps
from RPLCD import CharLCD      # Controls 1602 LCD with HD44780 driver
from picamera2 import Picamera2  # Interface for Raspberry Pi camera (libcamera-based)
import cv2                     # OpenCV for displaying video frames

# === GPIO PIN ASSIGNMENTS ===
TRIG = 5   # TRIG pin of ultrasonic sensor connected to GPIO 5
ECHO = 6   # ECHO pin of ultrasonic sensor connected to GPIO 6

# === GPIO INITIALIZATION ===
GPIO.setmode(GPIO.BCM)        # Use BCM numbering scheme
GPIO.setwarnings(False)       # Disable GPIO warnings
GPIO.setup(TRIG, GPIO.OUT)    # Set TRIG as an output pin
GPIO.setup(ECHO, GPIO.IN)     # Set ECHO as an input pin

# === LCD SETUP ===
lcd = CharLCD(
    cols=16, rows=2,           # LCD dimensions: 16 characters √ó 2 lines
    pin_rs=25,                 # Register Select pin
    pin_e=24,                  # Enable pin
    pins_data=[23, 17, 18, 22],# Data pins D4‚ÄìD7
    numbering_mode=GPIO.BCM    # Match BCM mode for consistency
)

# === CAMERA SETUP ===
picam2 = Picamera2()           # Initialize Picamera2 object
picam2.configure(picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}))  # 640x480 resolution, RGB format
picam2.start()                 # Start camera stream

# === FUNCTION TO MEASURE DISTANCE ===
def get_distance():
    GPIO.output(TRIG, True)
    time.sleep(0.00001)
    GPIO.output(TRIG, False)

    while GPIO.input(ECHO) == 0:
        pulse_start = time.time()

    while GPIO.input(ECHO) == 1:
        pulse_end = time.time()

    pulse_duration = pulse_end - pulse_start
    distance = pulse_duration * 17150  # Convert to cm
    return round(distance, 2)

# === MAIN PROGRAM LOOP ===
try:
    while True:
        distance = get_distance()
        lcd.clear()
        time.sleep(0.1)
        lcd.write_string(f"Dist: {distance:.2f} cm")

        frame = picam2.capture_array()
        cv2.imshow("Live Camera", frame)

        if cv2.waitKey(1) == ord('q'):
            break

        time.sleep(0.5)

except KeyboardInterrupt:
    pass

# === CLEANUP ON EXIT ===
lcd.clear()
GPIO.cleanup()
picam2.stop()
cv2.destroyAllWindows()</code></pre>
      </div>
    </details>

    <h4>üí° Expansion Ideas</h4>
    <ul>
      <li><strong>üì∏ Auto-Capture:</strong> Take photo if object is close
        <pre><code class="language-python">if distance < 10:
    picam2.capture_file("photo.jpg")
    lcd.write_string("Photo Taken!")</code></pre>
      </li>
      <li><strong>üé• Motion Triggered Video:</strong> Start recording if distance changes sharply
        <pre><code class="language-python">if abs(last_distance - distance) > 15:
    # Trigger recording</code></pre>
      </li>
      <li><strong>üåê IoT Logging:</strong> Send data to server or MQTT
        <pre><code class="language-python">requests.post("http://your-server/api", json={"distance": distance})</code></pre>
      </li>
      <li><strong>üîò Pushbutton Snapshot:</strong> Add GPIO button to take snapshot
        <pre><code class="language-python">if GPIO.input(BUTTON_PIN) == GPIO.LOW:
    picam2.capture_file("manual.jpg")</code></pre>
      </li>
    </ul>
  </details>
</section>



  <aside style="position: absolute; right: 10px; top: 100px; width: 220px;">
    <h3>üîå GPIO Reference</h3>
    <img src="media/gpio-diagram.png" alt="GPIO Pinout Reference" style="width: 100%; border-radius: 8px;" />
  </aside>

  <section class="qr-section">
    <h3>üì± Quick Access</h3>
    <p>Scan this QR code to return to the LiDAR Car Project website.</p>
    <img src="media/QRcode.jpg" alt="QR code to project website" class="qr-code" />
  </section>

  <footer>
    <p>¬© 2025 Connor Reagan, Hugo Acevedo, Dhruveen Sheth</p>
  </footer>

  <script src="js/main.js"></script>
</body>
</html>